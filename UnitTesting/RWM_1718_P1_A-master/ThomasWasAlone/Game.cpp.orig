#include "stdafx.h"

#include <iostream>
using namespace std;



#include "LTimer.h"
#include "Box.h"
#include "Sprite.h"
#include "Game.h"
#include "Player.h"

Sprite test;

const int SCREEN_FPS = 100;
const int SCREEN_TICKS_PER_FRAME = 1000 / SCREEN_FPS;


Game::Game()
{
	pause = false;
	quit = false;
	player = Player();
	player.col = Colour(255, 255, 100); 
}


Game::~Game()
{
}


bool Game::init() {	
	Size2D winSize(800,600);
	//creates our renderer, which looks after drawing and the window
	renderer.init(winSize,"Simple SDL App");

	//set up the viewport
	//we want the vp centred on origin and 20 units wide
	float aspectRatio = winSize.w / winSize.h;
	float vpWidth = 20;
	Size2D vpSize(vpWidth, vpWidth /aspectRatio);
	Point2D vpBottomLeft( -vpSize.w / 2, - vpSize.h / 2);

	Rect vpRect(vpBottomLeft,vpSize);
	renderer.setViewPort(vpRect);
<<<<<<< HEAD

	////create Game objects
	//Box* ground = new Box(Rect(-10, -10/aspectRatio, 50, 2));
	//ground->col = Colour(255, 255, 255);

	//Box* box1 = new Box(Rect(1.0f, -7.4 / aspectRatio, 1, 1));
	//box1->col = Colour(255, 255, 100);
	////add game objects to the world
	//gameObjects.push_back(ground);
	//gameObjects.push_back(box1);

	test.Init("Assets/Screen/Start.png", renderer, Rect(0, 0, 1600, 1600), Rect(0, 0, 800, 600));
=======
	//create Game objects
	Box* ground = new Box(Rect(-10, -10/aspectRatio, 50, 2));
	ground->col = Colour(255, 255, 255);


	//add game objects to the world
	gameObjects.push_back(ground);
>>>>>>> 4718d57af926fbc2bc8e381b3dd3905f4459c458

	lastTime = LTimer::gameTime();

	inputManager.AddListener(EventListener::Event::RIGHT, this);
	inputManager.AddListener(EventListener::Event::LEFT, this);
	inputManager.AddListener(EventListener::Event::RIGHTR, this);
	inputManager.AddListener(EventListener::Event::LEFTR, this);

	inputManager.AddListener(EventListener::Event::QUIT, this);
	inputManager.AddListener(EventListener::Event::LEVEL1, this);
	inputManager.AddListener(EventListener::Event::LEVEL2, this);
	inputManager.AddListener(EventListener::Event::LEVEL3, this);
	inputManager.AddListener(EventListener::Event::LEVEL4, this);
	inputManager.AddListener(EventListener::Event::ENDSCENE, this);
	inputManager.AddListener(EventListener::Event::STARSCENE, this);


	return true;

}


void Game::destroy()
{
	//empty out the game object vector before quitting
	for (std::vector<GameObject*>::iterator i = gameObjects.begin(); i != gameObjects.end(); i++) {
		delete *i;
	}

	gameObjects.clear();
	renderer.destroy();
}

//** calls update on all game entities*/
void Game::update()
{
	unsigned int currentTime = LTimer::gameTime();//millis since game started
	unsigned int deltaTime = currentTime - lastTime;//time since last update
	//call update for the game objects

	for (std::vector<GameObject*>::iterator i = gameObjects.begin(); i != gameObjects.end(); i++) {
		(*i)->Update(deltaTime);
	}

	player.Update(deltaTime);
	//save the curent time for next frame
	lastTime = currentTime;
}

//** calls render on all game entities*/

void Game::render()
{
	renderer.clear(Colour(0,0,0));// prepare for new frame
								  //render every object
	for (std::vector<GameObject*>::iterator i = gameObjects.begin(), e = gameObjects.end(); i != e; i++) {
		(*i)->Render(renderer);
	}
<<<<<<< HEAD

	test.Render(renderer);

=======
	
	player.Render(renderer);
>>>>>>> 4718d57af926fbc2bc8e381b3dd3905f4459c458
	renderer.present();// display the new frame (swap buffers)
}

/** update and render game entities*/
void Game::loop()
{
	LTimer capTimer;//to cap framerate

	int frameNum = 0;
	while (!quit) { //game loop
		capTimer.start();

		inputManager.ProcessInput();

		if (!pause) //in pause mode don't bother updateing
		{
			update();
		}
		render();

		int frameTicks = capTimer.getTicks();//time since start of frame
		if (frameTicks < SCREEN_TICKS_PER_FRAME)
		{
			//Wait remaining time before going to next frame
			SDL_Delay(SCREEN_TICKS_PER_FRAME - frameTicks);
		}
	}
}

void Game::onEvent(EventListener::Event evt) {

	switch (evt) {
	case EventListener::Event::RIGHT:
		player.right = true;
		break;
	case EventListener::Event::LEFT:
		player.left = true;
		break;
	case EventListener::Event::RIGHTR:
		player.right = false;
		player.rightReleased = true;
		break;
	case EventListener::Event::LEFTR:
		player.left = false;
		player.leftReleased = true;
		break;
	case EventListener::Event::QUIT:
		quit = true;
		break;
	}
	
	if (evt == EventListener::Event::QUIT) {
		quit=true;
	}
	if (evt == EventListener::Event::LEVEL1)
	{
		m_manager.ChangeStates(m_manager.level1);
	}
	if (evt == EventListener::Event::LEVEL2)
	{
		m_manager.ChangeStates(m_manager.level2);
	}
	if (evt == EventListener::Event::LEVEL3)
	{
		m_manager.ChangeStates(m_manager.level3);
	}
	if (evt == EventListener::Event::LEVEL4)
	{
		m_manager.ChangeStates(m_manager.level4);
	}
	if (evt == EventListener::Event::ENDSCENE)
	{
		m_manager.ChangeStates(m_manager.end);
	}
	if (evt == EventListener::Event::STARSCENE)
	{
		m_manager.ChangeStates(m_manager.start);
	}

}
